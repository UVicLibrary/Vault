# Generated by hyrax:models:install
class FileSet < ActiveFedora::Base
  # Do not include VaultBasicMetadata here. It causes tests to fail.
  # FileSet metadata/properties seem to be declared differently than other models.
  # TO DO: investigate further when upgrading to Hyrax 3.5

  property :creator, predicate: ::RDF::Vocab::DC11.creator, class_name: Hyrax::ControlledVocabularies::Creator


  property :alternative_title, predicate: ::RDF::Vocab::DC.alternative do |index|
    index.as :stored_searchable, :facetable
  end

  property :edition, predicate: ::RDF::Vocab::SCHEMA.bookEdition do |index|
    index.as :stored_searchable, :facetable
  end

  property :geographic_coverage, predicate: ::RDF::Vocab::DC.spatial, class_name: Hyrax::ControlledVocabularies::GeographicCoverage

  property :coordinates, predicate: ::RDF::Vocab::SCHEMA.geo do |index|
    index.as :stored_searchable, :facetable
  end

  property :chronological_coverage, predicate: ::RDF::Vocab::DC.temporal do |index|
    index.as :stored_searchable, :facetable
  end

  property :extent, predicate: ::RDF::Vocab::DC.extent do |index|
    index.as :stored_searchable, :facetable
  end

  property :additional_physical_characteristics, predicate: ::RDF::Vocab::SCHEMA.description do |index|
    index.as :stored_searchable, :facetable
  end

  property :has_format, predicate: ::RDF::Vocab::DC.hasFormat do |index|
    index.as :stored_searchable, :facetable
  end

  property :physical_repository, predicate: ::RDF::Vocab::PROV.atLocation do |index|
    index.as :stored_searchable, :facetable
  end

  property :provenance, predicate: ::RDF::Vocab::DC.provenance do |index|
    index.as :stored_searchable, :facetable
  end

  property :provider, predicate: ::RDF::Vocab::EDM.provider, class_name: Hyrax::ControlledVocabularies::Provider

  property :sponsor, predicate: ::RDF::Vocab::SCHEMA.sponsor do |index|
    index.as :stored_searchable, :facetable
  end

  property :genre, predicate: ::RDF::Vocab::SCHEMA.genre, class_name: Hyrax::ControlledVocabularies::Genre

  property :format, predicate: ::RDF::Vocab::DC.format do |index|
    index.as :stored_searchable, :facetable
  end

  property :is_referenced_by, predicate: ::RDF::Vocab::DC.isReferencedBy do |index|
    index.as :stored_searchable, :facetable
  end

  property :date_digitized, predicate: ::RDF::Vocab::DC.date do |index|
    index.as :stored_searchable, :facetable
  end

  property :transcript, predicate: ::RDF::Vocab::SCHEMA.transcript do |index|
    index.as :stored_searchable, :facetable
  end

  property :technical_note, predicate: ::RDF::URI.new('http://uvic.ca/ns/uvic#technicalNote') do |index|
    index.as :stored_searchable, :facetable
  end

  property :year, predicate: ::RDF::URI.new('http://library.uvic.ca/ns/uvic#year')

  property :last_fixity_check, predicate: ::RDF::URI.new('http://library.uvic.ca/ns/uvic#last_fixity_check'), multiple: false

  include ::Hyrax::FileSetBehavior

  property :creator, predicate: ::RDF::Vocab::DC11.creator, class_name: Hyrax::ControlledVocabularies::Creator

  property :contributor, predicate: ::RDF::Vocab::DC11.contributor, class_name: Hyrax::ControlledVocabularies::Contributor

  property :subject, predicate: ::RDF::Vocab::DC11.subject, class_name: Hyrax::ControlledVocabularies::Subject

  property :downloadable, predicate: ::RDF::URI.new('http://library.uvic.ca/ns/uvic#downloadable'), multiple: false

  property :part_of, predicate: ::RDF::Vocab::DC.isPartOf

  before_destroy :remove_rendering_relationship

  # Hyku has its own FileSetIndexer: app/indexers/file_set_indexer.rb
  # It overrides Hyrax to inject IIIF behavior.
  self.indexer = FileSetIndexer

  def rendering_ids
    to_param
  end

  # Returns md5 checksum (to be compared to original checksum)
  def current_checksum
    Digest::MD5.hexdigest self.files.first.content
  end

  id_blank = proc { |attributes| attributes[:id].blank? }

  self.controlled_properties += [:creator, :contributor, :physical_repository, :provider, :subject, :geographic_coverage, :genre]
  accepts_nested_attributes_for :creator, reject_if: id_blank, allow_destroy: true
  accepts_nested_attributes_for :contributor, reject_if: id_blank, allow_destroy: true
  accepts_nested_attributes_for :physical_repository, reject_if: id_blank, allow_destroy: true
  accepts_nested_attributes_for :provider, reject_if: id_blank, allow_destroy: true
  accepts_nested_attributes_for :subject, reject_if: id_blank, allow_destroy: true
  accepts_nested_attributes_for :geographic_coverage, reject_if: id_blank, allow_destroy: true
  accepts_nested_attributes_for :genre, reject_if: id_blank, allow_destroy: true

  def required?(term)
    Hyrax::FileSetForm.required_fields.include?(term)
  end

  # For some reason, the FileSet.properties do not come from the same place as
  # other models and so they don't have a class_name. Maybe they're being overridden
  # from somewhere else? Need to investigate further.
  def to_controlled_vocab
    controlled_properties.each do |field|
      if field.to_s == "based_near"
        class_name = "Hyrax::ControlledVocabularies::Location".constantize
      else
        class_name = "Hyrax::ControlledVocabularies::#{field.to_s.camelize}".constantize
      end
      # Convert Strings (URIs) to the proper classes
      values =  self[field].map do |val|
        val.include?("http") ? class_name.new(val.strip) : val
      end
      self.send(field.to_s + "=", values)
    end
  end

  private

  # If any parent objects are pointing at this object as their
  # rendering, remove that pointer.
  def remove_rendering_relationship
    parent_objects = parents
    return if parent_objects.empty?
    parent_objects.each do |work|
      if work.rendering_ids.class == Array and work.rendering_ids.include(id)
        new_rendering_ids = work.rendering_ids.delete(id)
        work.update(rendering_ids: new_rendering_ids)
      end
    end
  end
end
