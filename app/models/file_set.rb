# Generated by hyrax:models:install
class FileSet < ActiveFedora::Base

  # This list is copied from Hyrax::FileSetBehavior and
  # modified to omit Hyrax::BasicMetadata
  include Hyrax::WithEvents
  include Hydra::Works::FileSetBehavior
  include Hyrax::VirusCheck
  include Hyrax::FileSet::Characterization
  include Hydra::WithDepositor
  include Serializers
  include Hyrax::Noid
  include Hyrax::FileSet::Derivatives
  include Hyrax::Permissions
  include Hyrax::FileSet::Indexing
  include Hyrax::FileSet::BelongsToWorks
  include Hyrax::FileSet::Querying
  include Hyrax::HumanReadableType
  include Hyrax::CoreMetadata
  # include Hyrax::BasicMetadata
  include Hyrax::Naming
  include Hydra::AccessControls::Embargoable
  include GlobalID::Identification

  attr_accessor :file

  def representative_id
    to_param
  end

  def thumbnail_id
    to_param
  end

  # Cast to a SolrDocument by querying from Solr
  def to_presenter
    CatalogController.new.fetch(id).last
  end


  property :edition, predicate: ::RDF::Vocab::SCHEMA.bookEdition do |index|
    index.as :stored_searchable, :facetable
  end

  property :coordinates, predicate: ::RDF::Vocab::SCHEMA.geo do |index|
    index.as :stored_searchable, :facetable
  end

  property :chronological_coverage, predicate: ::RDF::Vocab::DC.temporal do |index|
    index.as :stored_searchable, :facetable
  end

  property :extent, predicate: ::RDF::Vocab::DC.extent do |index|
    index.as :stored_searchable, :facetable
  end

  property :additional_physical_characteristics, predicate: ::RDF::Vocab::SCHEMA.description do |index|
    index.as :stored_searchable, :facetable
  end

  property :has_format, predicate: ::RDF::Vocab::DC.hasFormat do |index|
    index.as :stored_searchable, :facetable
  end

  property :provenance, predicate: ::RDF::Vocab::DC.provenance do |index|
    index.as :stored_searchable, :facetable
  end

  property :sponsor, predicate: ::RDF::Vocab::SCHEMA.sponsor do |index|
    index.as :stored_searchable, :facetable
  end

  property :format, predicate: ::RDF::Vocab::DC.format do |index|
    index.as :stored_searchable, :facetable
  end

  property :is_referenced_by, predicate: ::RDF::Vocab::DC.isReferencedBy do |index|
    index.as :stored_searchable, :facetable
  end

  property :date_digitized, predicate: ::RDF::Vocab::DC.date do |index|
    index.as :stored_searchable, :facetable
  end

  property :transcript, predicate: ::RDF::Vocab::SCHEMA.transcript do |index|
    index.as :stored_searchable, :facetable
  end

  property :technical_note, predicate: ::RDF::URI.new('http://uvic.ca/ns/uvic#technicalNote') do |index|
    index.as :stored_searchable, :facetable
  end

  property :last_fixity_check, predicate: ::RDF::URI.new('http://library.uvic.ca/ns/uvic#last_fixity_check'), multiple: false

  property :identifier, predicate: ::RDF::Vocab::DC.identifier

  # This line must go below any custom properties
  include VaultBasicMetadata

  before_destroy :remove_rendering_relationship

  # Hyku has its own FileSetIndexer: app/indexers/file_set_indexer.rb
  # It overrides Hyrax to inject IIIF behavior.
  self.indexer = FileSetIndexer

  def rendering_ids
    to_param
  end

  # Returns md5 checksum (to be compared to original checksum)
  def current_checksum
    Digest::MD5.hexdigest self.files.first.content
  end

  def required?(term)
    Hyrax::FileSetForm.required_fields.include?(term)
  end

  private

  # If any parent objects are pointing at this object as their
  # rendering, remove that pointer.
  def remove_rendering_relationship
    parent_objects = parents
    return if parent_objects.empty?
    parent_objects.each do |work|
      if work.rendering_ids.class == Array and work.rendering_ids.include(id)
        new_rendering_ids = work.rendering_ids.delete(id)
        work.update(rendering_ids: new_rendering_ids)
      end
    end
  end
end
